<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Serverless Performance Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .dashboard {
        max-width: 1200px;
        margin: 0 auto;
      }
      .header {
        margin-bottom: 20px;
      }
      .metrics {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
      }
      .metric-card {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        flex: 1;
        min-width: 200px;
      }
      .metric-value {
        font-size: 24px;
        font-weight: bold;
        margin: 10px 0;
      }
      .chart-container {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      .chart-row {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
      }
      .chart-card {
        flex: 1;
        min-width: 45%;
      }
      .memory-size {
        color: #2563eb;
      }
      .concurrency {
        color: #16a34a;
      }
      .requests {
        color: #9333ea;
      }
      .execution-time {
        color: #f59e0b;
      }
      .cost {
        color: #ef4444;
      }
    </style>
  </head>
  <body>
    <div class="dashboard">
      <div class="header">
        <h1>Serverless Performance Dashboard</h1>
        <p>Real-time metrics for your serverless functions</p>
      </div>

      <div class="metrics">
        <div class="metric-card">
          <h3>Current Optimal Config</h3>
          <div class="metric-value memory-size" id="memory-size">--</div>
          <div>Memory Size (MB)</div>
          <div class="metric-value concurrency" id="concurrency">--</div>
          <div>Concurrency</div>
        </div>
        <div class="metric-card">
          <h3>Total Requests</h3>
          <div class="metric-value requests" id="total-requests">--</div>
          <div>Processed Requests</div>
        </div>
        <div class="metric-card">
          <h3>Recent Performance</h3>
          <div class="metric-value execution-time" id="latest-time">--</div>
          <div>Latest Execution Time (ms)</div>
          <div class="metric-value cost" id="latest-cost">--</div>
          <div>Latest Cost ($)</div>
        </div>
      </div>

      <div class="chart-row">
        <div class="chart-card chart-container">
          <h3>Execution Time Over Time</h3>
          <canvas id="time-chart"></canvas>
        </div>
        <div class="chart-card chart-container">
          <h3>Cost Over Time</h3>
          <canvas id="cost-chart"></canvas>
        </div>
      </div>

      <div class="chart-row">
        <div class="chart-card chart-container">
          <h3>Memory Usage Over Time</h3>
          <canvas id="memory-chart"></canvas>
        </div>
        <div class="chart-card chart-container">
          <h3>Configuration Comparison</h3>
          <canvas id="config-chart"></canvas>
        </div>
      </div>
    </div>

    <script>
      // Initialize charts
      const timeChart = new Chart(document.getElementById("time-chart"), {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "Execution Time (ms)",
              data: [],
              borderColor: "#8884d8",
              tension: 0.1,
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            y: {
              beginAtZero: true,
            },
          },
        },
      });

      const costChart = new Chart(document.getElementById("cost-chart"), {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "Cost ($)",
              data: [],
              borderColor: "#82ca9d",
              tension: 0.1,
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            y: {
              beginAtZero: true,
            },
          },
        },
      });

      const memoryChart = new Chart(document.getElementById("memory-chart"), {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "Memory Used (MB)",
              data: [],
              borderColor: "#ff7300",
              tension: 0.1,
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            y: {
              beginAtZero: true,
            },
          },
        },
      });

      const configChart = new Chart(document.getElementById("config-chart"), {
        type: "bar",
        data: {
          labels: [],
          datasets: [
            {
              label: "Avg Time (ms)",
              data: [],
              backgroundColor: "#8884d8",
            },
            {
              label: "Avg Cost ($)",
              data: [],
              backgroundColor: "#82ca9d",
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            y: {
              beginAtZero: true,
            },
          },
        },
      });

      // Function to update dashboard with latest data
      async function updateDashboard() {
        try {
          const response = await fetch("/api/metrics");
          const data = await response.json();

          // Update metric cards
          document.getElementById("memory-size").textContent =
            data.currentOptimalConfig.memorySize;
          document.getElementById("concurrency").textContent =
            data.currentOptimalConfig.concurrency;
          document.getElementById("total-requests").textContent =
            data.totalRequestsProcessed;

          // Get latest performance if available
          if (data.recentPerformance.length > 0) {
            const latest =
              data.recentPerformance[data.recentPerformance.length - 1];
            document.getElementById("latest-time").textContent =
              latest.executionTimeMs.toFixed(2);
            document.getElementById("latest-cost").textContent =
              latest.cost.toFixed(8);
          }

          // Format time series data for charts
          const timeLabels = data.recentPerformance.map((item, index) => {
            const date = new Date(item.timestamp);
            return date.toLocaleTimeString();
          });

          const executionTimes = data.recentPerformance.map(
            (item) => item.executionTimeMs
          );
          const costs = data.recentPerformance.map((item) => item.cost);
          const memoryUsages = data.recentPerformance.map(
            (item) => item.memoryUsedMb
          );

          // Update time chart
          timeChart.data.labels = timeLabels;
          timeChart.data.datasets[0].data = executionTimes;
          timeChart.update();

          // Update cost chart
          costChart.data.labels = timeLabels;
          costChart.data.datasets[0].data = costs;
          costChart.update();

          // Update memory chart
          memoryChart.data.labels = timeLabels;
          memoryChart.data.datasets[0].data = memoryUsages;
          memoryChart.update();

          // Group by configuration to show comparison
          const configMap = {};
          data.recentPerformance.forEach((item) => {
            const key = `${item.memorySize}MB-${item.concurrency}`;
            if (!configMap[key]) {
              configMap[key] = {
                name: key,
                avgTime: 0,
                avgCost: 0,
                count: 0,
              };
            }
            configMap[key].avgTime += item.executionTimeMs;
            configMap[key].avgCost += item.cost;
            configMap[key].count++;
          });

          // Calculate averages
          const configComparison = Object.values(configMap).map((config) => ({
            name: config.name,
            avgTime: parseFloat((config.avgTime / config.count).toFixed(2)),
            avgCost: parseFloat((config.avgCost / config.count).toFixed(8)),
          }));

          // Update config comparison chart
          configChart.data.labels = configComparison.map((item) => item.name);
          configChart.data.datasets[0].data = configComparison.map(
            (item) => item.avgTime
          );
          configChart.data.datasets[1].data = configComparison.map(
            (item) => item.avgCost
          );
          configChart.update();
        } catch (error) {
          console.error("Failed to fetch metrics:", error);
        }
      }

      // Initial update
      updateDashboard();

      // Update every 5 seconds
      setInterval(updateDashboard, 5000);
    </script>
  </body>
</html>
